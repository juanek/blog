<!DOCTYPE html>
<html lang="es">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Juan E. Kipes Blog</title>


  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,600" rel="stylesheet" type="text/css">
  <!--<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600' rel='stylesheet' type='text/css'>-->
<link rel="stylesheet" href="/css/main.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-126646878-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-126646878-1');
</script> 
    




 
   <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Archivo | Juan E. Kipes Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Archivo" />
<meta name="author" content="Juan E. Kipes" />
<meta property="og:locale" content="es_AR" />
<meta name="description" content="Un blog dedicado al desarrollo de software, lenguaje Java , administración linux y herramientas para aplicaciones web en general." />
<meta property="og:description" content="Un blog dedicado al desarrollo de software, lenguaje Java , administración linux y herramientas para aplicaciones web en general." />
<link rel="canonical" href="http://localhost:4000/archivos/" />
<meta property="og:url" content="http://localhost:4000/archivos/" />
<meta property="og:site_name" content="Juan E. Kipes Blog" />
<script type="application/ld+json">
{"description":"Un blog dedicado al desarrollo de software, lenguaje Java , administración linux y herramientas para aplicaciones web en general.","author":{"@type":"Person","name":"Juan E. Kipes"},"@type":"WebPage","url":"http://localhost:4000/archivos/","headline":"Archivo","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <!-- NAV -->
<nav class="navbar navbar-expand-md navbar-light py-4">
  <div class="container">
    <a href="/" class="navbar-brand">
      <h2 class="d-inline align-middle pl-3 text-primary">Juan E. Kipes</h2>
    </a>
    <button class="navbar-toggler" data-toggle="collapse" data-target="#navbarNav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a href="/archivos/" class="nav-link">Archivos</a>
        </li>
        <li class="nav-item">
          <a href="/acerca/" class="nav-link">Sobre Mí</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

    <section id="banner" class="py-5 d-none d-sm-block">
  <div class="primary-overlay text-white">
    <div class="container">
      <div class="row">
        <div class="col-md-12 text-center">
          <!--<h1 class="display-5 pt-1">
	      ...un blog para compartir código...
      </h1>-->
      </div>
<!--      <div class="col-md-2"></div>-->
    </div>
  </div>
</section>

    <section id="archive">
  <div class="container py-3">
    <div class="row">
      <div class="col">
        <script src="/js/lunr.js"></script>

<script>

var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "Not found",
    "body": "      No se encontró nada aquí!   "
    }, {
    "id": 1,
    "url": "http://localhost:4000/acerca/",
    "title": "Acerca de mí",
    "body": " Me llamo Juan Edgardo Kipes, vivo en Santa Fe, Argentina. Soy Ingeniero en Sistemas de Información de la UTN-FRSF. El desarrollo de software es mi pasión y mi profesión. Actualmente trabajo como desarrollador Freelancer de aplicaciones web relacionadas al mundo Java. Autodidacta, minimalista y fan del software libre. Es difícil, si no imposible, aprender un tema tan sólo leyéndolo, sin aplicar la información a problemas específicos que te estimulen en pensar en lo que has leído. Además, se aprenden mejor las cosas que uno descubre por sí mismo. —DONALD KNUTH, The Art of Computer ProgrammingPara contactarme: Email: juanekipes@gmail. com "
    }, {
    "id": 2,
    "url": "http://localhost:4000/archivos/",
    "title": "Archivo",
    "body": "{% include archive. html %} "
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "",
    "body": "{% include posts. html %}{% include pagination. html %} "
    }, {
    "id": 4,
    "url": "http://localhost:4000/tag/java/",
    "title": "Etiquetado como #java",
    "body": ""
    }, {
    "id": 5,
    "url": "http://localhost:4000/tag/linux/",
    "title": "Etiquetado como #linux",
    "body": ""
    }, {
    "id": 6,
    "url": "http://localhost:4000/tag/logback/",
    "title": "Etiquetado como #logback",
    "body": ""
    }, {
    "id": 7,
    "url": "http://localhost:4000/css/main.css",
    "title": "",
    "body": "@import ‘bootstrap/bootstrap’;@import ‘custom/includes/header’;@import ‘custom/includes/banner’;@import ‘custom/includes/social_links’;@import ‘custom/includes/posts’;@import ‘custom/includes/pagination’;@import ‘custom/includes/post’;@import ‘github. css’;@import ‘custom/includes/archive’; "
    }, {
    "id": 8,
    "url": "http://localhost:4000/tag/maven/",
    "title": "Etiquetado como #maven",
    "body": ""
    }, {
    "id": 9,
    "url": "http://localhost:4000/page2/",
    "title": "",
    "body": "{% include posts. html %}{% include pagination. html %} "
    }, {
    "id": 10,
    "url": "http://localhost:4000/usar-java-enum/",
    "title": "Cómo usar los Java Enum.",
    "body": "2019/01/19 - Contenido:  Introducción ¿Qué son los Java enums? Los enum en lugar de constantes int Los enum como Singleton.  Reemplazar los if anidados por enum.  Usar interfaces para extender enum.  Conclusiones.  Referencias. Introducción. : Los Enums son una parte muy porderosa e importante del lenguaje Java. Aunque son muy útiles no siempre son usados correctamente. En este post veremos como usarlos y en que casos son útiles. ¿Qué son los Java enums?. : Un tipo enumerado en Java es un tipo cuyos valores consisten de conjunto fijo de constantes. En Java, los enumerados son tipos de clases que tienen un conjunto predefinido de instancias. Pueden tener constructores, métodos, campos … Son como clases, con algunas pocas diferencias específicas:  Extienden de java. lang. Enum Tienen un conjunto fijo de instancias.  Pueden ser usadas en sentencias No puedes ser extendidasLos Enums son similares a las clases por lo tanto pueden ser usadas para muchas mas cosas que solo representar enumeraciones. Los Enum en lugar de constantes int. : Un tipo enumerado es un tipo que consiste de un conjunto fijo de constantes, como estaciones del año, los planetas del sistema solar o los palos de un mazo de naipes. Una forma comun de representar enumerados es usar el int enum pattern // El int enum pattern - tiene muchas deficiencias!public static final int APPLE_FUJI      = 0;public static final int APPLE_PIPPIN     = 1;public static final int APPLE_GRANNY_SMITH  = 2;public static final int ORANGE_NAVEL     = 0;public static final int ORANGE_TEMPLE    = 1;public static final int ORANGE_BLOOD     = 2;Una forma más elegante elegante y segura es usar enum. public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }public enum Orange { NAVEL, TEMPLE, BLOOD }Los enum como Singleton. : Usando enum en Java es fácil implementar el patrón Singleton: public enum Singleton {  INSTANCE;  private Singleton() {    //Es llamado la primera vez cuando el enum es inicializado    System. out. println( I am initialised );  }}Como puedes ver, provee una simple y correcta implementación del patron Singleton. Además, como es un enum, este no tiene que ser una sola instancia, podrían ser dos … Reemplazar los if anidados por enum. : Para mostrar un ejemplo, vamos a modelar el juego Piedra-Papel-Tijera para ello usamos un enumerado que representa las tres señas posibles. enum HandSign { SCISSOR, PAPER, ROCK }Queremos obtener una seña aleatorio para la máquina y mostrar un mensaje en consola. Una posible implementación sería: //generar un enum aleatoriocomputerMove = HandSign. values()[new Random(). nextInt(HandSign. values(). length)];//mostar mensaje informando la opción generadaif (computerMove == HandSign. SCISSOR) {  System. out. println(   Mi turno: Tijera );} else if (computerMove == HandSign. PAPER) {  System. out. println(   Mi turno: Papel );} else {  System. out. println(   Mi turno: Piedra );}Este caso es muy sencillo, unos pocos estados y con un comportamiento asociado muy sencillo, mostrar un mensaje. También se podría haber usado la sentencia switch, pero una forma mas elegante es representarlo usando enum. El enum ahora además de representar un conjunto fijo de constantes tiene una lógica asociada a cada constante mediante el método abstracto show(). public enum HandSign {  SCISSOR {    @Override    public void show() {      System. out. println(   Mi turno: Tijera );    }  },  PAPER {    @Override    public void show() {      System. out. println(   Mi turno: Papel );    }  },  ROCK {    @Override    public void show() {      System. out. println(   Mi turno: Piedra );    }  };  public abstract void show();}Hemos logrado encapsulación y un código fuente mas legible. //generar señacomputerMove = HandSign. values()[new Random(). nextInt(HandSign. values(). length)];//mostrar señaHandSign. valueOf(computerMove. name()). show();Usar interfaces para extender enum. : Como mencionammos al comienzo de este post, los enum no pueden ser extendidos. La mayoría de las veces extender enums es una mala idea, pero hay casos donde tiene sentido. Para el caso nuestro juego Piedra-Papel-Tijera, tenemos un enumerado que describe los distintos niveles de juego y una comportamiento asociado, usando la misma técnica del método abstracto. public enum GameMode {  LEVEL_NOVICE {    @Override    public Game proccesGame(HandSign player, Params params) {      // lógica que procesa el juego nivel novato    }  }, LEVEL_GOD {    @Override    public Game proccesGame(HandSign player, Params params) {      // lógica que procesa el juego nivel Dios    }  };  public abstrac Game proccesGame(HandSign player, Params params);}El problema con este enumerado es que no esta basado en un conjunto fijo de constantes bien conocidas, y puede darse el caso que en futuros requerimiento podríamos tener que soportar otros niveles de juegos, por ejemplo, un nuevo nivel LEVEL_ADVANCED. El enumerado anterior HandSign que describe las señas posibles del juego Piedra-Papel-Tijera no va a cambiar en el tiempo porque define el juego, si agregáramos mas señas el juego sería otro. Una posibilidad sería modificar el código fuente de GameMode, agregar esta nueva constante e implementar el método abstracto. Esto viola uno de los principios SOLID ,el principio de Abierto/Cerrado, cerrado a la modificación y abierto a la extensión. Los enum violan el principio Abierto/Cerrado porque no permiten la extensión sin modificación. La forma de solucionar esto, es usar una interface mas que un enum, a veces esto se hace instintivamente cuando trabajamos con clases. public interface IGameMode {  public abstract Game proccesGame(HandSign player, Params params);}Y el enumerado implementando la interface IGameMode. public enum GameMode implements IGameMode {  LEVEL_NOVICE {    @Override    public Game proccesGame(HandSign player, Params params) {    }  }, LEVEL_GOD {    @Override    public Game proccesGame(HandSign player, Params params) {    }  };}Ahora ya podemos crear un nuevo enum que implemente la interface IGameMode para la constante LEVEL_ADVANCED y lograr extensión sin modificación. Conclusiones. : Los enum de Java son poderosos para modelar dominios que describen un conjunto fijo de constantes, como son clases podemos asociarles información y comportamiento. Los enum son una alternativa al uso de sentencia swith e if anidados. Los enum no permiten la extensión, siempre debes evaluar el dominio y determinar si modificas el código agregando el nuevo estado al enumerado o usas interface. El principio Abierto/Cerrado, es un principio y no un dogma a ser aplicado en todos los casos. Usamos el juego Priedra-Papel-Tijera para mostrar el uso de los enum, el código fuente puedes verlo en https://github. com/juanek. $ mvn exec:java -Dexec. mainClass= ar. com. jekipes. enums. RockPaperScissors Vamos a comenzar. . . Piedra-Papel-Tijera(Ingresa s para Tijera , p para Papel, t para Piedra, q para salir): sTu Turno: TijeraMi turno: Papel*************************************************** Tu ganas!***************************************************Piedra-Papel-Tijera(Ingresa s para Tijera , p para Papel, t para Piedra, q para salir):Referencias. : https://docs. oracle. com/javase/tutorial/java/javaOO/enum. html https://blog. scottlogic. com/2016/07/28/java-enums-how-to-use-them-smarter. html Effective Java, 3rd Edition "
    }, {
    "id": 11,
    "url": "http://localhost:4000/logback-aplicacion-java/",
    "title": "Agrega Logback a tu aplicación Java.",
    "body": "2018/10/13 - Contenido:  1 - Introducción.  2 - Logger, Appenders y Layouts.  3 - Configuración.  4 - Ejemplo básico y configuración.  5- Logger contextos.  6 - Configuración detallada.  7 - Appenders.  8 - Layouts Conclusiones.  Referencias. Una guía para Logback. 1 - Introducción: Logback es uno de los frameworks de logging más populares en la comunidad Java, fue creado como sucesor del proyecto Log4j. Dado que el logging es una parte crucial de cualquier aplicación tanto para propósitos de debugger como de auditoría, elegir la adeucuada librería de logging es una decisión importante para cualquier proyecto. ¿Porqué elegir Logback?  Es más rápido que Log4j.  Arquitectura modular.  Fácil de integrar con sistemas legacy.  Altamente configurable. Veremos la como está diseñado Logback y como usarlo para desarrollar mejores aplicaciones. 2 - Logger, Appenders y Layouts: Logback está desarrollado en torno a tres clases principales: Logger, Appender y Layout. Logger es un contexto para los mensajes de log. Esta es la clase que interactúa con las aplicaciónes para crear mensajes de log. Los Appenders son los lugares a donde serán dirigidos los mensajes de log. Un Logger puede tener más de un Appender. Generalmente pensamos en los Appenders como la consola o archivos de textos, pero Logback es más potente que esto. La clase Layout es la encargada de darle formato a la salida de los mensages de log. Logback soporta la creación de clases personalizadas para el formateo de los mensajes, así como también robustas opciones de configuración para las ya existentes. 3 - Dependencias. : Necesitamos crear un proyecto maven de ejemplo y agregar las dependencias. Logback usa Simple Logging Facade para Java (SLF4J) como su interfaz nativa. Así que necesitamos agregar Logback y SLF4J a nuestro pom. xml &lt;dependency&gt;   &lt;groupId&gt;ch. qos. logback&lt;/groupId&gt;   &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;   &lt;version&gt;1. 2. 3&lt;/version&gt;   &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org. slf4j&lt;/groupId&gt;   &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;   &lt;version&gt;1. 7. 25&lt;/version&gt;&lt;/dependency&gt;Maven central tiene la última version de Logback core y la versión mas reciente de slfj-api. 4 - Ejemplo básico. : Vamos a comenzar con un ejemplo sencillo de usar Logback en una aplicación. Primero necesitamos un archivo de configuración. Creamos un archivo de texto llamado logback. xml y lo ponemos en algún lugar en nuestro classpath, en este caso en /src/main/resources/logback. xml ├── pom. xml├── README. md├── src│   ├── main│   │   ├── java│   │   │   └── ar│   │   │     └── com│   │   │       └── jekipes│   │   │         ├── App. java│   │   │         └── Simple. java│   │   └── resources│   │     └── logback. xml&lt;configuration&gt; &lt;appender name= STDOUT  class= ch. qos. logback. core. ConsoleAppender &gt;  &lt;encoder&gt;   &lt;pattern&gt;%d{HH:mm:ss. SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;  &lt;/encoder&gt; &lt;/appender&gt; &lt;root level= INFO &gt;  &lt;appender-ref ref= STDOUT  /&gt; &lt;/root&gt;&lt;/configuration&gt;Además necesitamos una clase simple con un método main. Para registrar un mensaje de log con Logback, inicializamos un Logger desde SLF4J o Logback y lo usamos public class Simple {  private static final Logger logger = LoggerFactory. getLogger(Simple. class);  /**   * @param args the command line arguments   */  public static void main(String[] args) {    logger. info( Hello world from {} , Simple. class. getSimpleName());  }}Ejecutamos nuestro programa $ mvn exec:java -Dexec. mainClass= ar. com. jekipes. Simple12:58:26. 895 [ar. com. jekipes. Simple. main()] INFO ar. com. jekipes. Simple - Hello world from SimpleEsta clase crea un Logger y llama al método info() para generar un mensaje de log. Es fácil ver porque Logback es tan popular, podemos configurarlo y comenzar a usarlo en minutos. Esta configuración y este código nos dá unas pocas pistas de como trabaja.  1 - Tenemos un appender llamado STDOUT que referencia a la clase ConsoleAppender.  2 - Hay un tag que describe el formato de nuestro mensaje de log.  3 - Nuestro código crea un Logger y le pasamos nuestro mensaje vía el método info()Ahora que comprendemos lo básico , vamos a un análisis más detallado. 5- Logger: 5. 1 - Niveles de logs. : Como vimos arriba en el archivo logback. xml podemos configurar el logger para mostrar mensajes de distintos tipos, trace, error, info, etc.  Estos son los niveles de logs que maneja logback. TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROREn nuestro ejemplo, el root looger está configurado a nivel INFO, si cambiamos logger. info() por logger. debug() veremos que no imprime nada. y si volvemos a reemplazar logger. debug() por logger. warn() veremos que el logger registra mensajes de log. REGLA: Cualquier logger con nivel X puede manejar mensajes de nivel Y, donde Y &gt;= X. 5. 2 - Jerarquías de logs. : Otro concepto importante de la configuración de logs es la jeraquía de los mismos. Para comprender mejor este concepto vamos a modificar nuestro logback. xml con el siguiente contenido &lt;configuration&gt;  &lt;appender name= STDOUT  class= ch. qos. logback. core. ConsoleAppender &gt;    &lt;encoder&gt;      &lt;pattern&gt;%d{HH:mm:ss. SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;logger name= ar. com. jekipes  level= INFO &gt;    &lt;appender-ref ref= STDOUT  /&gt;  &lt;/logger&gt;  &lt;root level= INFO &gt;    &lt;appender-ref ref= STDOUT /&gt;  &lt;/root&gt;&lt;/configuration&gt;En la configuración de arriba tenemos dos logger, el logger root y el logger ar. com. jekipes. Agregamos el siguiente código y ejecutamos el programa. public class HierarchyLogs {  /**   * @param args the command line arguments   */  public static void main(String[] args) {    Logger logger = LoggerFactory. getLogger(HierarchyLogs. class. getSimpleName());    logger. info( Hello world!!! );    logger = LoggerFactory. getLogger(HierarchyLogs. class. getPackage(). getName());    logger. info( Hello world again!! );  }}Este código nos imprimirá en consola 08:13:55. 231 [ar. com. jekipes. HierarchyLogs. main()] INFO HierarchyLogs - Hello world!!!08:13:55. 234 [ar. com. jekipes. HierarchyLogs. main()] INFO ar. com. jekipes - Hello world again!!08:13:55. 234 [ar. com. jekipes. HierarchyLogs. main()] INFO ar. com. jekipes - Hello world again!!Cuando logger. info() es llamado desde el looger root sólo una sentencia se imprime en consola pero cuando es invocado desde el logger ar. com. jekipes se imprime dos veces. Y esto se debe a la jerarquía de logs. Para evitar esto, agregamos la propiedad additivity=false. De esta manera sólo el logger ar. com. jekipes manejará los mensajes.   &lt;logger name= ar. com. jekipes  level= INFO  additivity=false&gt;    &lt;appender-ref ref= STDOUT  /&gt;  &lt;/logger&gt;La configuración de los Logger se realiza de manera jerárquica, en donde el Logger padre de todos los demás es root. Cada Logger adicional se jerarquiza basado en su nombre y usando puntos como separador, así un Logger de nombre ar. com. jekipes es padre de ar. com. jekipes. util por lo que este último hereda la configuración definida en logback. xml para su Logger padre. Regla: La jerarquía de logs significa que un logger (X. Y) es automáticamnte considerado padre de todos los loggers nombrados (X. Y. *). Si el logger padre está definido en la configuración, cualquiera de los mensajes de log dirigidos al logger hijo también seran manejados por el logger padre. 5. 3 - Parametrizando mensajes. : Logback permite usar multiples parámetros y además el último argumento puede ser tratado como una exception. logger. error( one two three four five: {} {} {} {} {} ,  1 ,  2 ,        3 , 4 ,  5 ,new Exception( error ));Ejecutamos este código y en consola veremos 20:33:19. 903 [main] ERROR ParametersMessagesTest - one two three four fivr: 1 2 3 4 5java. lang. Exception: error	at ar. com. jekipes. ParametersMessagesTest. parameters1(ParametersMessagesTest. java:54)	at sun. reflect. NativeMethodAccessorImpl. invoke0(Native Method)	at sun. reflect. NativeMethodAccessorImpl. invoke(NativeMethodAccessorImpl. java:62)	at sun. reflect. DelegatingMethodAccessorImpl. invoke(DelegatingMethodAccessorImpl. java:43)	at java. lang. reflect. Method. invoke(Method. java:498)6 - Configuración detallada. : 6. 1 - Ubicando el archivo de configuración: Los pasos de inicialización que Logback sigue para intentar configurarse son los siguientes  Logback intenta encontrar un archivo llamado logback-test. xml en el classpath.  Sino intenta encontrar el archivo llamado logback. groovy en el classpath.  Sino busca el archivo logback. xml en el classpath. Si no encuentra ningun archivo de configuración, logback se configura a si mismo usando el BasicConfigurator el cual causa la salida de los mensajes de log directamente de consola. Con un proyecto Maven, puedes usar el archivo src/test/resources/logback-test. xml y el archivo src/main/resources/logback. xml para producción. logback-quickstart$ tree. ├── config│   └── config. xml├── nbproject│   └── project. properties├── pom. xml├── README. md├── src│   ├── main│   │   ├── java│   │   │   └── ar│   │   │     └── com│   │   │       └── jekipes│   │   │         ├── App. java│   │   │         ├── HierarchyLogs. java│   │   │         └── Simple. java│   │   └── resources│   │     └── logback. xml│   └── test│     ├── java│     │   └── ar│     │     └── com│     │       └── jekipes│     │         ├── AppTest. java│     │         └── ParametersMessagesTest. java│     └── resources│       └── logback-test. xmlOtra opción, logback permite especificar un archivo de configuración usando el parámetro logback. configurationFile.  mvn exec:java -Dexec. mainClass= ar. com. jekipes. Simple  -Dlogback. configurationFile=/path/to/logback-quickstart/config/config. xml6. 3 - Solución a problemas de configuración. : Para ver la información de depuración de cómo Logback procesa la configuración, puedes activar el modo debug.  &lt;configuration debug= true &gt; . . .  &lt;/configuration&gt;Hay un segundo mecanismo para imprimir la información de estado: &lt;configuration&gt;  &lt;statusListener class= ch. qos. logback. core. status. OnConsoleStatusListener  /&gt;  . . . &lt;/configuration&gt;El StatusListener, intercepta los mensajes de estado y los imprime durante la configuración y mientras el programa está corriendo. 6. 4 - Recarga automática de la configuración. : Recargar el archivo de configuración de logback mientras la aplicación está corriendo es una poderosa herramienta de solución de problemas. Logback hace esto posible con el parámetro scan &lt;configuration scan= true &gt; . . . &lt;/configuration&gt;El comportamiento por defecto es escanear el archivo de configuración en busca de modificaciones cada 60 segundos. Se modifica este intervalo agregando scanPeriod &lt;configuration scan= true  scanPeriod= 15 seconds &gt; . . . &lt;/configuration&gt;Podemos especificar valores en “milliseconds”, “seconds”, “minutes”, o “hours”. 7 - Appenders. : 7. 1 - ConsoleAppender. : Como su nombre lo describe, agrega mensajes al System. out o al System. err y es el archivo logback. xml que hemos estado usando hasta ahora. 7. 2 - FileAppender. : FileAppender agrega mensajes a un archivo. Agregamos el appender “name=File” a nustro archivo de configuración y lo referenciamos desde el logger, así &lt;configuration debug= true &gt;  &lt;property name= PATH  value= /home/juan/logs  /&gt;  &lt;property name= APP  value= myapp  /&gt;  &lt;appender name= STDOUT  class= ch. qos. logback. core. ConsoleAppender &gt;    &lt;encoder&gt;      &lt;pattern&gt;%d{HH:mm:ss. SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;appender name= FILE  class= ch. qos. logback. core. FileAppender &gt;    &lt;file&gt;${PATH}/${APP}. log&lt;/file&gt;    &lt;append&gt;true&lt;/append&gt;    &lt;encoder&gt;      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;logger name= ar. com. jekipes  level= INFO  additivity= false &gt;    &lt;appender-ref ref= FILE  /&gt;  &lt;/logger&gt;	&lt;logger name= ar. com. jekipes. Simple  level= TRACE  &gt;    &lt;appender-ref ref= STDOUT  /&gt;  &lt;/logger&gt;  &lt;root level= OFF &gt;    &lt;appender-ref ref= STDOUT /&gt;  &lt;/root&gt;&lt;/configuration&gt;Usamos el tag para configurar el nombre del archivo y nos valemos de la definición de las variables **PATH** y **APP** para construir el nombre completo del archivo de log. El tag instruye a Appender a agregar los logs a un archivo si este existe. La propiedad additivity en false del logger “ar. com. jekipes” permitirá no registrar los mensajes de logs en consola ni ninguno de sus descendiente y sólo se mostrarán el archivo de log. Para probar esta configuración ejecutamos el programa invocando directamente el archivo de configuración mvn exec:java -Dexec. mainClass= ar. com. jekipes. Simple  -Dlogback. configurationFile=path/to/logback-quickstart/config/configFileAppender. xml7. 3 - RollingFileAppender. : RollingFileAppender nos brinda la posibilidad de rotar los archivos de log de acuerdo a alguna politica. Para este ejemplo usamos el TimeBasedRollingPolicy, que define una política basada en tiempo, por ejemplo por dia o por mes. Con esta configuración logback rotará los archivos diariamente y los moverá al directorio PATH_BACKUP comprimidos en formato gz. Se mantendrán hasta 30 archivos o hasta que estos archivos superen los 3GB, eliminando los más antiguos. &lt;configuration debug= true &gt;  &lt;property name= PATH  value= /home/juan/logs  /&gt;  &lt;property name= PATH_BACKUP  value= /home/juan/logs/backups  /&gt;  &lt;property name= APP  value= myapp  /&gt;  &lt;appender name= FILE  class= ch. qos. logback. core. rolling. RollingFileAppender &gt;    &lt;file&gt;${PATH}/${APP}. log&lt;/file&gt;    &lt;rollingPolicy class= ch. qos. logback. core. rolling. TimeBasedRollingPolicy &gt;      &lt;fileNamePattern&gt;${PATH_BACKUP}/${APP}. %d{yyyy-MM-dd}. gz&lt;/fileNamePattern&gt;      &lt;maxHistory&gt;30&lt;/maxHistory&gt;      &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;    &lt;/rollingPolicy&gt;    &lt;encoder&gt;      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;logger name= ar. com. jekipes  level= INFO  additivity= false &gt;    &lt;appender-ref ref= FILE  /&gt;  &lt;/logger&gt;  &lt;logger name= ar. com. jekipes. Simple  level= TRACE  &gt;    &lt;appender-ref ref= FILE  /&gt;  &lt;/logger&gt;  &lt;root level= OFF &gt;    &lt;appender-ref ref= FILE /&gt;  &lt;/root&gt;&lt;/configuration&gt;mvn exec:java -Dexec. mainClass= ar. com. jekipes. Simple  -Dlogback. configurationFile=path/to/logback-quickstart/config/configRollingAppender. xml8 - Layouts: Los Layouts formatean los mensajes de log. Como en el resto de Logback, los Layouts se pueden extender y crear propios, Sim embargo, el aptron por defecto PatterLayout ofrece lo que la mayoría de las aplicaciones necesitan y mas. Hemos usado el patrón PatternLayout en todas nuestros ejemplos hasta ahora &lt;encoder&gt;  &lt;pattern&gt;%d{HH:mm:ss. SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;&lt;/encoder&gt;Esta parte de la configuración contiene la configuración del PatterLayoutEncoder. Le pasamos un Encoder a nuestro Appender, y este enconder usa el PatternLayout para formatear los mensajes. El texto de tag define como los mensajes de log son formateados. PatternLayout implemnta una larga variedad de conversión de palabras y modifcadores de formatos para crear patrones. Vamos a descomponer esto. PatternLayout reconoce las palabras de conversión con un %, de esta manera las conversiones en nuestro patrón genera:  %d{HH:mm:ss. SSS} – un timestamp con horas, minutos, segundos y milisegundos.  [%thread] – el nombre del hilo que genera los mensajes de log entre corchete %-5level – el nivel del evento de log en un bloque de 5 caracteres.  %logger{36} – el nombre del logger, limitado a 35 caracteres.  %msg%n – los mensajes de log seguido de un separador de linea dependiente de la plataforma. Conclusión. : Logback es uno de los frameworks de logging más populares en la comunidad Java. Es un reemplazo para su antecesor Log4j. Logback ofrece una implementación más veloz que Log4j, provee más opciones de configuración y más flexibilidad para rotar archivos de logs. Herramienta imprescindible para hacer mejores aplicaciones. Referencias: Manual de Logback https://www. baeldung. com/logback https://stackoverflow. com/ "
    }, {
    "id": 12,
    "url": "http://localhost:4000/proyectos-arquetipos-maven/",
    "title": "Cómo crear proyectos y arquetipos con Maven.",
    "body": "2018/09/26 - En esta guía vamos a crear proyectos Java con Maven directamente desde la consola de comandos de manera interactiva y no-interactiva. Además, generaremos un arquetipo desde un proyecto existente. Contenido:  1 - Crear proyectos en modo interactivo.  2 - Crear proyectos en modo no-interactivo.  3 - Crear arquetipos desde un proyecto.  4 - Compilar y construir proyectos.  5 - Ejecutar programas.  6 - Ejecutar pruebas.  7 - Resumen de comandos útiles.  Conclusiones.  Referencias. 1 - Crear proyectos en modo interactivo. : Para crear un proyecto en modo interactivo usamos el comando $ mvn archetype:generateEste comando nos listará los arquetipos disponibles y nos mostrará en consola el prompt solicitando ingresar el número de arquetipo o algun filtro, por ejemplo “quickstart” para que nos muestre todos los arquetipos que contengan este filtro. Por defecto, Maven nos seleccionará el arquetipo que contiene un ejemplo de proyecto Maven, en este caso es el 1255.  Enter y seleccionamos la opción por defecto.  Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 1255:Posteriormente debemos especificar groupId, artifactId, version y package. Maven nos generará un proyecto con la siguiente estructura. $ tree. ├── pom. xml└── src  ├── main  │   └── java  │     └── ar  │       └── com  │         └── jekipes  │           └── App. java  └── test    └── java      └── ar        └── com          └── jekipes            └── AppTest. java11 directories, 3 filesY el correspondiente descriptor del proyecto pom. xml &lt;project xmlns= http://maven. apache. org/POM/4. 0. 0  xmlns:xsi= http://www. w3. org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven. apache. org/POM/4. 0. 0 http://maven. apache. org/maven-v4_0_0. xsd &gt; &lt;modelVersion&gt;4. 0. 0&lt;/modelVersion&gt; &lt;groupId&gt;ar. com. jekipes&lt;/groupId&gt; &lt;artifactId&gt;MavenQuickstart&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1. 0-SNAPSHOT&lt;/version&gt; &lt;name&gt;MavenQuickstart&lt;/name&gt; &lt;url&gt;http://maven. apache. org&lt;/url&gt; &lt;dependencies&gt;  &lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;3. 8. 1&lt;/version&gt;   &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;2 - Crear proyectos en modo no-interactivo. : La otra forma de generar proyectos es el modo no-interactivo o batch, especificando los parámetros en el mismo comando $ mvn archetype:generate -DgroupId=ar. com. jekipes -DartifactId=MavenQuickstart -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=falseLos parámetros para este comando archetype:generate son:  groupId: es el identificador de paquetes de tu proyecto dentro de todos los proyectos. Sigue las reglas del nombrado de paquetes en Java.  artefactId: define el nombre de proyecto.  archetypeArtifactId: define el nombre del arquetipo.  interactiveMode: false para usar el modo no-interactivo. De esta forma obtendremos un proyecto similar al que generamos arriba. 3 - Crear arquetipos desde un proyecto. : Ahora ya sabemos como crear proyectos Java con Maven a partir de los arquetipos que nos provve Maven. Pero también podemos crear nuestros propios arquetipos que generen proyectos con la estructura y dependencias que necesitemos. Vamos a ver un ejemplo sencillo, de crear un arquetipo desde un proyecto existente. El ejemplo anterior lo modificamos para poder crear un arquetipos que genere proyectos cosn la librería JUnit 4 y esté configurado para trabajar con logback. Para ello modificamos el pom. xml y agregamos las dependencias &lt;project xmlns= http://maven. apache. org/POM/4. 0. 0  xmlns:xsi= http://www. w3. org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven. apache. org/POM/4. 0. 0 http://maven. apache. org/maven-v4_0_0. xsd &gt; &lt;modelVersion&gt;4. 0. 0&lt;/modelVersion&gt; &lt;groupId&gt;ar. com. jekipes&lt;/groupId&gt; &lt;artifactId&gt;MavenQuickstart&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1. 0-SNAPSHOT&lt;/version&gt; &lt;name&gt;MavenQuickstart&lt;/name&gt; &lt;url&gt;http://maven. apache. org&lt;/url&gt; &lt;dependencies&gt;  &lt;dependency&gt;   &lt;groupId&gt;ch. qos. logback&lt;/groupId&gt;   &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;   &lt;version&gt;1. 2. 3&lt;/version&gt;   &lt;scope&gt;runtime&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;org. slf4j&lt;/groupId&gt;   &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;   &lt;version&gt;1. 7. 25&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4. 12&lt;/version&gt;   &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;Para agregar el archivo de configuración de logs de Logback, creamos un nuevo directorio resources. $ mkdir -p src/test/resources$ touch src/test/resources/logback-test. xmlUn simple archivo de configuración para logback logback-test. xml. &lt;configuration&gt;  &lt;appender name= console  class= ch. qos. logback. core. ConsoleAppender &gt;    &lt;target&gt;System. out&lt;/target&gt;    &lt;encoder&gt;      &lt;pattern&gt;%d{HH:mm:ss. SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;root level= info &gt;    &lt;appender-ref ref= console /&gt;  &lt;/root&gt;&lt;/configuration&gt;Actualizamos la clase de test AppTest. java para que soporte JUnit 4. package ar. com. jekipes;import static org. junit. Assert. assertTrue;import org. junit. Test;import org. slf4j. LoggerFactory;import org. slf4j. Logger;public class AppTest { private static final Logger logger = LoggerFactory. getLogger(AppTest. class. getSimpleName()); @Test public void evalTest() {	logger. info( hello test!!! );    assertTrue( true ); }}Ahora generamos el arquetipo con el comando $ mvn archetype:create-from-project[INFO] Scanning for projects. . . [INFO][INFO] ------------------------------------------------------------------------[INFO] Building MavenQuickstart 1. 0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] &gt;&gt;&gt; maven-archetype-plugin:3. 0. 1:create-from-project (default-cli) &gt; generate-sources @ MavenQuickstart &gt;&gt;&gt;[INFO][INFO] &lt;&lt;&lt; maven-archetype-plugin:3. 0. 1:create-from-project (default-cli) &lt; generate-sources @ MavenQuickstart &lt;&lt;&lt;[INFO][INFO] --- maven-archetype-plugin:3. 0. 1:create-from-project (default-cli) @ MavenQuickstart ---[INFO] Setting default groupId: ar. com. jekipes[INFO] Setting default artifactId: MavenQuickstart[INFO] Setting default version: 1. 0-SNAPSHOT[INFO] Setting default package: ar. com. jekipes[INFO] Scanning for projects. . . [INFO] . . . [INFO] ------------------------------------------------------------------------[INFO] Archetype project created in /home/juan/tuto/MavenQuickstart/target/generated-sources/archetype[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------Nos interesa recordar groupId, artifactId y version de nuestro nuevo arquetipo, ya que luego estos parámetros son requeridos para la generación de nuevos proyectos. Instalamos el arquetipo generado en nuestro repositorio local. $ cd target/generated-sources/archetype/$ mvn installAhora ya podemos crear nuevos proyectos desde nuestro arquetipo. mvn archetype:generate -DarchetypeGroupId=ar. com. jekipes -DarchetypeArtifactId=MavenQuickstart-archetype -DarchetypeVersion=1. 0-SNAPSHOT -DgroupId=ar. com. jekipes -DartifactId=logback-quickstart -DinteractiveMode=falseObserva los parámetros que identifican el arquetipo. -DarchetypeGroupId=ar. com. jekipes-DarchetypeArtifactId=MavenQuickstart-archetype-DarchetypeVersion=1. 0-SNAPSHOTLa estructura deseada de nuestro proyecto. $ tree logback-quickstartlogback-quickstart├── pom. xml└── src  ├── main  │   └── java  │     └── ar  │       └── com  │         └── jekipes  │           └── App. java  └── test    ├── java    │   └── ar    │     └── com    │       └── jekipes    │         └── AppTest. java    └── resources      └── logback-test. xml12 directories, 4 filesY sus dependencias. $ mvn dependency:tree[INFO] Scanning for projects. . . [INFO][INFO] ------------------------------------------------------------------------[INFO] Building logback-quickstart 1. 0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] --- maven-dependency-plugin:2. 8:tree (default-cli) @ logback-quickstart ---[INFO] ar. com. jekipes:logback-quickstart:jar:1. 0-SNAPSHOT[INFO] +- ch. qos. logback:logback-classic:jar:1. 2. 3:runtime[INFO] | \- ch. qos. logback:logback-core:jar:1. 2. 3:runtime[INFO] +- org. slf4j:slf4j-api:jar:1. 7. 25:compile[INFO] \- junit:junit:jar:4. 12:test[INFO]  \- org. hamcrest:hamcrest-core:jar:1. 3:test[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------4 - Compilar y construir proyectos. : Maven se basa en el concepto de ciclo de vida de construcción de un proyecto. De manera que el proceso para construir y distribuir un proyecto esta claramente definido. Hay tres ciclos de vida para la construcción de proyectos proyectos predefinidos, el ciclo de limpieza, el ciclo por defecto o de construcción y el ciclo de generación de la documentación. Cada uno de estos ciclos está constituído por fases, donde cada fase representa un estado en el ciclo de vida de construcción del proyecto.  Por ejemplo, el ciclo de vida Default comprende las siguientes fases  validate - valida que el proyecto esté correcto y toda lainformación necesaria este disponible compile - compila el código fuente del proyecto test - se corren las pruebas unitarias usando el framework de testing. Estas pruebas no requieren que el código fuente esté empaquetado o desplegado.  package - toma el código compilado y lo empaqueta en algun formato distribuible como como un archivo JAR.  verify - se verifican los resultados de las pruebas de integración install - se intala el paquete en el repositorio local, para usar como dependencias de otros proyectos localmente deploy - copia el empaquetado final al repositorio remoto para ser comprtido por otros desarroladores y proyectos. Estas fases (además de otras que no se muestran en este listado) son ejecutadas secuencialmente para completar el ciclo de vida Default. Para empaquetar el proyecto e instalarlo en el repositorio local se puede usar $ mvn installEste comando ejecuta cada una de las fases del ciclo de vida Default en orden (validate, compile, package, etc. ) antes de ejecutar la fase install. Puedes combinar fases de los ciclos de vida Clean y Default, para limpiar el proyecto eliminando lo generado anteriormente en /target y compilar y crear un jar del proyecto con $ mvn clean package5 - Ejecutar programas con Maven. : Puedes ejecutar el proyecto compilado y empaquetado anteriormente usando directamente el comando java $ java -cp target/logback-quickstart-1. 0-SNAPSHOT. jar ar. com. jekipes. AppHello World!O puedes usar un plugin Maven que te permite ejecutar el método main de alguna clase Java de tu proyecto, incluyendo en el classpath automáticamente todas las dependencias. Agregamos al final de nuestro pom. xml el plugin exec-maven-plugin   &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org. codehaus. mojo&lt;/groupId&gt;        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;1. 6. 0&lt;/version&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;Y ejecutamos la clase Java con $ mvn exec:java -Dexec. mainClass= ar. com. jekipes. App Hello World!Considera revisar la documentación de este plugin para un uso más avanzado exec-maven-plugin. 6 - Ejecutar pruebas con Maven. : En la fase de test puedes invocar una prueba en particular con $ mvn -Dtest=ar. com. jekipes. AppTest test. . . ------------------------------------------------------- T E S T S-------------------------------------------------------Running ar. com. jekipes. AppTest22:15:57. 555 [main] INFO AppTest - hello test!!!Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0. 521 sec - in ar. com. jekipes. AppTest7 - Resumen de comandos útiles. :      Resumen de comandos Maven       Crear un proyecto   mvn archetype:generate       Crear arquetipo desde un proyecto   mvn archetype:create-from-project       Limpiar el proyecto   mvn clean       Limpiar y compilar   mvn clean compile       Limpiar, compilar y empaquetar   mvn clean package       Instalar en el repositorio local   mvn install       Instalar en el repositorio remoto   mvn deploy       Ejecutar la prueba AppTest   mvn -Dtest=org. myapp. AppTest test       Ejecutar un aplicación   java -cp target/myapp-1. 0-SNAPSHOT. jar org. myapp. App       Ejecutar una aplicación usando Maven   mvn exec:java -Dexec. mainClass= org. myapp. App     Conclusiones. : En esta guía hemos visto las principales características de Apache Maven y como usarlas desde la linea de comandos para generar arquetipos y proyectos. El código fuente utilizado para este ejemplo lo puedes encontrar en el Repositorio GitHub Referencias. : https://maven. apache. org/guides/getting-started/maven-in-five-minutes. html https://maven. apache. org/guides/mini/guide-naming-conventions. html https://docs. oracle. com/javase/specs/jls/se6/html/packages. html#7. 7 http://maven. apache. org/guides/introduction/introduction-to-the-lifecycle. html http://www. mojohaus. org/exec-maven-plugin. "
    }, {
    "id": 13,
    "url": "http://localhost:4000/usar-systemctl-servicios/",
    "title": "Usar systemctl para administrar servicios en Linux",
    "body": "2018/09/24 - Contenido:  Instalar el servidor Resin.  Crear nuestro archivo . service.  Administrar nuestro servicio Arrancar y parar servicios.  Reiniciar servicios.  Habilitar y deshabilitar servicios.  Verificar el estado de un servicio.  Ver los registros del sistema.  Recursos útiles. Los servicios son programas que corren continuamente en el sistema, esperando por eventos externos para procesar alguna cosa y que hagan a esto todo el tiempo. Hay muchos servicios ejecutándose todo el tiempo en un servidor Linux. Como servidor web, base de datos, FTP,SSH, impresión,DHCP, servidor LDAP. Systemctl es un programa que se usa para administrar las tareas de los servicios. Con el comando systemctl podemos iniciar y parar un servicio, habilitarlo como demonio, controlar el estado actual del mismo. Además podemos configurar algunas opciones de arranque y permisos de ejecución. Vamos a mostrar como administrar y trabajar con servicios, instalando un servidor de aplicaciones Resin y hacer las configuraciones necesarias para administrarlo con systemctl. Instalar el servidor Resin. Descargamos la última versión estable de Resin. wget http://caucho. com/download/resin-4. 0. 58. tar. gzDescomprimimos resin-4. 0. 58. tar. gz en un directorio resin-test. tar xzfv resin-4. 0. 58. tar. gz -C resin-test --strip-components=1Lo movemos a /opt/resin-test y ubicados en /opt/resin-test verificamos que funciona correctamente. Iniciar el servidor Resin. sh bin/resin. sh startVerificar que esta corriendo el port 8080 con el comando curl curl http://localhost:8080Deberíamos ver la Home Page de Resin. &lt;html&gt; &lt;head&gt;  &lt;title&gt;Resin&amp;#174; Default Home Page&lt;/title&gt;&lt;/head&gt;  &lt;body&gt;     &lt;h1 style= background: #ccddff &gt;Resin&amp;#174; Default Home Page&lt;/h1&gt;      This is the default page for the Resin web server.       &lt;p&gt;Documentation is available at &lt;a href= /resin-doc &gt;/resin-doc&lt;/a&gt;.       &lt;p&gt;Administration is available at &lt;a href= /resin-admin &gt;/resin-admin&lt;/a&gt;.   &lt;/body&gt;&lt;/html&gt;Parar el servidor Resin. sh bin/resin. sh stopTenemos instalado un servidor de aplicaciones web Resin, sabemos como iniciar y parar el servicio web. Vamos a crear un archivo . service para poder administar este servicio con el comando systenctl. Para una instalación y configuración mas avanzada del servidor, ver Resin Crear nuestro archivo . service. Vamos a crear un unproceso que se encargue de iniciar y vigilar nuestro servidor web Resin (volver a iniciarlo si se para, reiniciarlo cuando el sistema se reinicie, poder controlar su estado…). En systemd estos procesos se definen y configuran en los archivos denominados de unidad, con extensión . service Creamos un archivo resin-test. service en el directorio /etc/systemd/system. touch resin-test. serviceEl contenido de nuestro archivo . service es [Unit]Description=Resin Test serviceAfter=syslog. target[Service]Type=forkingEnvironment=JAVA_HOME=/usr/lib/jvm/java-8-oracleEnvironment=RESIN_HOME=/opt/resin-testSyslogIdentifier=Resin TestExecStart=/bin/sh /opt/resin-test/bin/resin. sh startExecStop=/bin/sh /opt/resin-test/bin/resin. sh stopUser=juan[Install]WantedBy=multi-user. targetexplicar que hace este archivo Los archivos unit consisten de tres secciones: [Unit]: Description: una descripción significativa del archivo de unidad. Este texto se mostrará cuando se usa el comando systemctl status. After: define el orden que arrancará la unidad. La unidad arrancará después que la unidad especificada en After esté activa. La opción Before tiene la funcionalidad opuesta a After. [Service]: Type: especifica el tipo de arranque que afectará a la funcionalidad de ExecStart y sus opciones. Una de estas opciones puede ser Forking, en esta opción el proceso comienza con ExecStart y crea un proceso hio que se convierte en el proceso principal del servicio, el proceso padre espera hasta ser notificado que esta todo bien para dar por finalizado el proceso de inicio exitoso. Environment esta directiva nos permite configurar variables de entorno para ejecutar nustro proceso. SyslogIdentifier este identificador será de utilidad para identificar nuestro servicio en los registros del sistema. ExecStart especifica comandos o script a ser ejecutados para arrancar la unidad. ExecStartPre y ExecStartPostespecifican los comandos a ser ejecutados antes y despues de ExecStart. ExecStop especifica comandos o scripts a ser ejecutados para parar la unidad. [Install]: Esta sección es opcional e indica que es lo que se debería ocurrir cuando la unidad se habilite. WantedByWantedBy	cuando se habilite, esta nueva unidad pasará formar parte del grupo de unidades conocidas como multi-user. target, el servicio arrancará cuando el sistema alcance el nivel runLevel 2. La tabla de target y sus run levels:       Run Lvl   Target Units   Description         0   runlevel0. target, poweroff. target   Shut down and power off       1   runlevel1. target, rescue. target   Set up a rescue shell       2,3,4   runlevel[234]. target,multi-user. target   Set up a non-gfx multi-user shell       5   runlevel5. target, graphical. target   Set up a gfx multi-user shell       6   runlevel6. target, reboot. target   Shut down and reboot the system   Para una descrición detallada , ver CREATING AND MODIFYING SYSTEMD UNIT FILES Administrar nuestro servicio. Ahora notificamos a systemd que existe un nuevo . service ejecutando el comando sudo systemctl daemon-reload Cada vez que creamos un nuevo . service o modificacmos uno existente debemos ejecutar el comando systemctl daemon-reload Ahora podemos administrar nuestro resin-test. service como cualquier otro servicio. Arrancar y parar servicios. Para iniciar un servicio, systemd ejecuta las instrucciones del archivo de unidad del servicio, usando el comando start. Si estas ejecutando comandos como usuario no root, debes usar sudo ya que esto afecta el estado del sistema operativo. sudo systemctl start resin-test. servicePara parar un servicio que está ejecutándose puedes usar el comando stop. Reiniciar servicios. To restart a running service, you can use the restart command: sudo systemctl restart resin-test. serviceHabilitar y deshabilitar servicios. Los comandos de arriba son útiles para iniciar o para el servicio dureante la sesión actual. Para notificar a systemd que inicie el servicio automáticamnete durante el boot, debes habilitarlo. Para habilitar el servicio se usa el comando enabled. juan@juan:~$sudo systemctl enable resin-test. serviceCreated symlink from /etc/systemd/system/multi-user. target. wants/resin-test. service to /etc/systemd/system/resin-test. service. Esto creará un enlace simbólico a nuestro . service en la ubicación donde systemd busca los archivos de autoarranque. Para deshabilitar el autoarranque usa el comando disable. juan@juan:~$sudo systemctl disable resin-test. serviceRemoved symlink /etc/systemd/system/multi-user. target. wants/resin-test. service. Puedes verificar si un servicio tiene habilitado el autoarranque con el comando is-enabled. sudo systemctl is-enabled resin-test. serviceVerificar el estado de un servicio. Para verificar el estado de un servicio en tu sistema, puede usar el comando status juan@juan:~$ systemctl status resin-test. service● resin-test. service - Resin Test service  Loaded: loaded (/etc/systemd/system/resin-test. service; disabled; vendor preset: enabled)  Active: active (running) since sáb 2018-09-19 17:25:50 -03; 45min ago Main PID: 7811 (java)  CGroup: /system. slice/resin-test. service      ├─7811 /usr/lib/jvm/java-8-oracle/bin/java -Dresin. watchdog=app-0 -Djava. util. logging. manager=com. caucho. log      └─7867 /usr/lib/jvm/java-8-oracle/bin/java -Dresin. server=app-0 -Djava. util. logging. manager=com. caucho. log. Lsep 19 17:25:46 juan systemd[1]: Starting Resin Test service. . . sep 19 17:25:47 juan Resin Test[7767]: Resin/4. 0. 58 launching watchdog at 127. 0. 0. 1:6600sep 19 17:25:49 juan Resin Test[7767]: Resin/4. 0. 58 started -server 'app-0' with watchdog at 127. 0. 0. 1:6600sep 19 17:25:50 juan systemd[1]: Started Resin Test service. Ver los registros del sistema. Finalmente podemos usar Journalctl que es la herramienta más utilizada para acceder a los registros del sistema y filtrar los registros pertenecientes a nuestro servicio journalctl -u resin-test. serviceRecursos útiles. http://www. caucho. com/ https://www. digitalocean. com/community/tutorials/understanding-systemd-units-and-unit-files https://wiki. archlinux. org/index. php/Systemd "
    }, {
    "id": 14,
    "url": "http://localhost:4000/verificar-uso-disco/",
    "title": "Como liberar espacio de disco en linux.",
    "body": "2018/09/15 - Contenido:  1 - Analizar el espacion es disco.  2 - Buscar los archivos y directorios mas grandes.  3 - Eliminar archivos y directorios.  Conclusiones.  Referencias. 1 - Analizar el espacio en disco. : El comando “df” muestra la información del nombre del dispositivo, total de bloques, espacio de disco usado, la disponibilidad de espacio en disco y los puntos de montaje del sistema. Este comando significa disk filesystem. Podemos usar df -h o df -k para ver una lista del uso del disco. El comando df provee una opción para mostar el tamaño de los archivos y directorios en un formato “Human Readable” usando “-h”, imprime los resultados en un formato mas comprensible, por ejemplo, 1K,2M, 3G. Al ejecutar este comando veras una serie de columnas como S. ficheros, Tamaño, Usados, Disp Uso% y Montado en. $ df -hS. ficheros   Tamaño Usados Disp Uso% Montado enudev       3,9G   0 3,9G  0% /devtmpfs      794M  9,5M 784M  2% /run/dev/sda1    451G  220G 208G 52% /tmpfs      3,9G  72M 3,9G  2% /dev/shmtmpfs      5,0M  4,0K 5,0M  1% /run/locktmpfs      3,9G   0 3,9G  0% /sys/fs/cgroupcgmfs      100K   0 100K  0% /run/cgmanager/fstmpfs      794M  84K 793M  1% /run/user/1000En esta caso vemos que tenemos disponible 208G y un porcentaje de uso de 52%. 2 - Buscar los archivos y directorios mas grandes. : Cuando ya tenemos una estadística del uso del disco, sabremos si tenemos la necesidad de liberar espacio. Para esto primero podemos identificar cuáles son los archivos y directorios que ocupan mas espacio usando el comando du (Disk Usage) . Algunos de las combinaciones de comandos du que podemos usar    Obtener el tamaño de todos los archivos y sub directorios recursivamente, en formato legible del directorio /home/juan/Documentos/cursoPython/ con un indicador del tamaño de total de uso al final.  juan@juan:~$ du -ahc /home/juan/Documentos/cursoPython/0	/home/juan/Documentos/cursoPython/tutorial/ejercicio2. py4,0K	/home/juan/Documentos/cursoPython/tutorial/ejemploExisteDirectorio. py52K	/home/juan/Documentos/cursoPython/tutorial/dependencias. txt60K	/home/juan/Documentos/cursoPython/tutorial932K	/home/juan/Documentos/cursoPython/apuntes/curso-python. pdf936K	/home/juan/Documentos/cursoPython/apuntes4,0K	/home/juan/Documentos/cursoPython/indice. txt4,0K	/home/juan/Documentos/cursoPython/libros1008K	/home/juan/Documentos/cursoPython/1008K	total   Cuando el árbol de directorios sobre el que necesitamos obtener irnformación es grande, podemos limitar su profundidad con la opción –max-depth= juan@juan:~$ du -ahc --max-depth=1 /home/juan/bitbucket/java/448K	/home/juan/bitbucket/java/CalculatorWS_Client_Application. 152K	/home/juan/bitbucket/java/java-gson200K	/home/juan/bitbucket/java/. git4,0K	/home/juan/bitbucket/java/. gitignore184K	/home/juan/bitbucket/java/CalculatorWSApplication760K	/home/juan/bitbucket/java/java-test232K	/home/juan/bitbucket/java/CalculatorWSClient0	/home/juan/bitbucket/java/mitexto. txt2,0M	/home/juan/bitbucket/java/2,0M	total   Si sólo queremos obtener información de los directorios podemos usar.  juan@juan:~$ du -hc --max-depth=1 /home/juan/bitbucket/java/448K	/home/juan/bitbucket/java/CalculatorWS_Client_Application. 152K	/home/juan/bitbucket/java/java-gson200K	/home/juan/bitbucket/java/. git184K	/home/juan/bitbucket/java/CalculatorWSApplication760K	/home/juan/bitbucket/java/java-test232K	/home/juan/bitbucket/java/CalculatorWSClient2,0M	/home/juan/bitbucket/java/2,0M	total   obtener los 5 acrhivos y/o directorios más grandes de /home/juan/bitbucket/java/ $ du -ah /home/juan/bitbucket/java/ | sort -n -r | head -n 5800K	/home/juan/bitbucket/java/java-test512K	/home/juan/bitbucket/java/java-test/target448K	/home/juan/bitbucket/java/CalculatorWS_Client_Application. 276K	/home/juan/bitbucket/java/java-test/src232K	/home/juan/bitbucket/java/java-test/target/surefire-reports   obtener los 5 acrhivos y/o directorios más grandes de /home/juan/bitbucket/java/ en un formato más legible $ cd /home/juan/bitbucket/java/$ du -hs * | sort -rh | head -5800K	java-test448K	CalculatorWS_Client_Application. 232K	CalculatorWSClient184K	CalculatorWSApplication152K	java-gson3 - Eliminar archivos y directorios. : Para eliminar archivos y/o directoros usamos el comando rm.    borrar todo el contenido de /home/juan/temp/* $ rm /home/juan/temp/*   borrar todo el contenido mostrando los mensajes de debug $ rm -v /home/juan/temp/*   borrar todo el contenido recursivamente sin preguntar $ rm -rfv /home/juan/temp/ -r : remover el directorio y su contenido recursivamente.  -f : opción forzar, ignora archivos inexistentes, nunca muestra el prompt -v : opción verboseConclusiones. : En esta guía vimos los comandos básicos para analizar el uso del disco con el comando df, obtener los archivos y directorios que más espacio ocupan con el comando du y cómo eliminarlos con el comando rm. Referencias. : https://www. ibm. com/support/knowledgecenter/en/SSLTBW_2. 3. 0/com. ibm. zos. v2r3. bpxa500/df. htm https://www. tecmint. com/check-linux-disk-usage-of-files-and-directories/ man df man du "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Resultados encontrados para '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sin resultados ...</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #008A3C;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <p><input type="text" class="form-control" id="lunrsearch" name="q" maxlength="155" value="" placeholder="Buscar en los posts" /></p>
</form>
<div id="lunrsearchresults">
    <ul></ul>
</div>

      </div>
  </div>
    <div class="row">
      <div class="col">
        <h2 class="text-primary">Archivos</h2>
        <ul>
          
            <li>
              <span>Jan 19, 2019</span> -
              <a href="/usar-java-enum/">Cómo usar los Java Enum.</a>
            </li>
          
            <li>
              <span>Oct 13, 2018</span> -
              <a href="/logback-aplicacion-java/">Agrega Logback a tu aplicación Java.</a>
            </li>
          
            <li>
              <span>Sep 26, 2018</span> -
              <a href="/proyectos-arquetipos-maven/">Cómo crear proyectos y arquetipos con Maven.</a>
            </li>
          
            <li>
              <span>Sep 24, 2018</span> -
              <a href="/usar-systemctl-servicios/">Usar systemctl para administrar servicios en Linux</a>
            </li>
          
            <li>
              <span>Sep 15, 2018</span> -
              <a href="/verificar-uso-disco/">Como liberar espacio de disco en linux.</a>
            </li>
          
        </ul>
      </div>
    </div>
  </div>
</section>


    <footer class="py-5">
  <hr>
  <div class="container text-center text-info">
    <div class="row">
      <div class="col">
        
          <div class="social-links">
  <a target="_blank" href="https://github.com/juanek">
    <i class="fab fa-github fa-2x"></i>
  </a>
  <a href="mailto:juanekipes@gmail.com">
    <i class="fa fa-envelope fa-2x" ></i>
  </a>
  <a target="_blank" href="https://github.com/juanek">
    <i class="fab fa-pinterest fa-2x"></i>
  </a>
  <!--<a target="_blank" href="https://twitter.com/">
    <i class="fab fa-twitter fa-2x"></i>
  </a>-->
</div>

        
      </div>
    </div>
    <div class="row">
      <div class="col">
        Juan E. Kipes &copy; 2019.
      </div>
    </div>
  </div>
</footer>

<!-- JS -->
<script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js" integrity="sha384-SlE991lGASHoBfWbelyBPLsUlwY1GwNDJo3jSJO04KZ33K2bwfV9YBauFfnzvynJ" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
 <script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.4.0/highlightjs-line-numbers.min.js"></script>
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
    //hljs.initLineNumbersOnLoad();
    hljs.initLineNumbersOnLoad({
    singleLine: true
});
 </script>

  </body>
</html>
